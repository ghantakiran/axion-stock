"""Data models for AI Trading Copilot."""

from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Optional
import uuid

from src.copilot.config import (
    RiskTolerance,
    InvestmentStyle,
    ResponseStyle,
    AnalysisType,
    IdeaStatus,
    IdeaOutcome,
)


def _new_id() -> str:
    return uuid.uuid4().hex[:16]


def _now() -> datetime:
    return datetime.now(timezone.utc)


@dataclass
class CopilotMessage:
    """A single message in a copilot conversation."""

    role: str  # user, assistant, system
    content: str
    message_id: str = field(default_factory=_new_id)
    timestamp: datetime = field(default_factory=_now)
    tokens_used: int = 0
    model: str = ""
    extracted_symbols: list[str] = field(default_factory=list)
    extracted_actions: list[str] = field(default_factory=list)
    confidence_score: Optional[float] = None
    user_rating: Optional[int] = None
    feedback: Optional[str] = None

    def to_dict(self) -> dict:
        """Convert to dictionary for API/storage."""
        return {
            "message_id": self.message_id,
            "role": self.role,
            "content": self.content,
            "timestamp": self.timestamp.isoformat(),
            "tokens_used": self.tokens_used,
            "model": self.model,
            "extracted_symbols": self.extracted_symbols,
            "extracted_actions": self.extracted_actions,
            "confidence_score": self.confidence_score,
            "user_rating": self.user_rating,
        }


@dataclass
class CopilotSession:
    """A copilot conversation session."""

    user_id: str
    session_id: str = field(default_factory=_new_id)
    title: str = "New Chat"
    session_type: str = "chat"
    messages: list[CopilotMessage] = field(default_factory=list)
    context: dict = field(default_factory=dict)
    active_symbol: Optional[str] = None
    started_at: datetime = field(default_factory=_now)
    last_activity_at: datetime = field(default_factory=_now)
    is_active: bool = True

    @property
    def message_count(self) -> int:
        return len(self.messages)

    def add_message(self, role: str, content: str, **kwargs) -> CopilotMessage:
        """Add a message to the session."""
        msg = CopilotMessage(role=role, content=content, **kwargs)
        self.messages.append(msg)
        self.last_activity_at = _now()
        return msg

    def get_context_messages(self, limit: int = 20) -> list[dict]:
        """Get recent messages for context."""
        recent = self.messages[-limit:] if len(self.messages) > limit else self.messages
        return [{"role": m.role, "content": m.content} for m in recent]

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "session_id": self.session_id,
            "user_id": self.user_id,
            "title": self.title,
            "session_type": self.session_type,
            "message_count": self.message_count,
            "active_symbol": self.active_symbol,
            "started_at": self.started_at.isoformat(),
            "last_activity_at": self.last_activity_at.isoformat(),
            "is_active": self.is_active,
        }


@dataclass
class CopilotPreferences:
    """User preferences for the copilot."""

    user_id: str
    risk_tolerance: RiskTolerance = RiskTolerance.MODERATE
    investment_style: InvestmentStyle = InvestmentStyle.BALANCED
    time_horizon: str = "medium"  # short, medium, long
    preferred_sectors: list[str] = field(default_factory=list)
    excluded_sectors: list[str] = field(default_factory=list)
    response_style: ResponseStyle = ResponseStyle.BALANCED
    include_technicals: bool = True
    include_fundamentals: bool = True
    include_sentiment: bool = True
    max_position_size_pct: Optional[float] = None
    min_market_cap: Optional[int] = None

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "user_id": self.user_id,
            "risk_tolerance": self.risk_tolerance.value,
            "investment_style": self.investment_style.value,
            "time_horizon": self.time_horizon,
            "preferred_sectors": self.preferred_sectors,
            "excluded_sectors": self.excluded_sectors,
            "response_style": self.response_style.value,
            "include_technicals": self.include_technicals,
            "include_fundamentals": self.include_fundamentals,
            "include_sentiment": self.include_sentiment,
            "max_position_size_pct": self.max_position_size_pct,
            "min_market_cap": self.min_market_cap,
        }


@dataclass
class TradeIdea:
    """A trade idea generated by the copilot."""

    symbol: str
    action: str  # buy, sell, hold
    idea_id: str = field(default_factory=_new_id)
    user_id: str = ""
    session_id: Optional[str] = None
    message_id: Optional[str] = None
    confidence: float = 0.5
    rationale: str = ""
    entry_price: Optional[float] = None
    target_price: Optional[float] = None
    stop_loss: Optional[float] = None
    time_horizon: str = "medium"
    status: IdeaStatus = IdeaStatus.ACTIVE
    created_at: datetime = field(default_factory=_now)
    expires_at: Optional[datetime] = None
    executed_at: Optional[datetime] = None
    execution_price: Optional[float] = None
    outcome: Optional[IdeaOutcome] = None
    outcome_pct: Optional[float] = None

    @property
    def upside_pct(self) -> Optional[float]:
        """Calculate potential upside percentage."""
        if self.entry_price and self.target_price:
            return (self.target_price - self.entry_price) / self.entry_price * 100
        return None

    @property
    def risk_pct(self) -> Optional[float]:
        """Calculate downside risk percentage."""
        if self.entry_price and self.stop_loss:
            return (self.entry_price - self.stop_loss) / self.entry_price * 100
        return None

    @property
    def risk_reward_ratio(self) -> Optional[float]:
        """Calculate risk/reward ratio."""
        upside = self.upside_pct
        risk = self.risk_pct
        if upside and risk and risk > 0:
            return upside / risk
        return None

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "idea_id": self.idea_id,
            "symbol": self.symbol,
            "action": self.action,
            "confidence": self.confidence,
            "rationale": self.rationale,
            "entry_price": self.entry_price,
            "target_price": self.target_price,
            "stop_loss": self.stop_loss,
            "time_horizon": self.time_horizon,
            "upside_pct": self.upside_pct,
            "risk_pct": self.risk_pct,
            "risk_reward_ratio": self.risk_reward_ratio,
            "status": self.status.value,
            "created_at": self.created_at.isoformat(),
        }


@dataclass
class PortfolioContext:
    """Portfolio context for copilot analysis."""

    total_value: float = 0.0
    cash_balance: float = 0.0
    positions_value: float = 0.0
    day_pnl: float = 0.0
    day_return_pct: float = 0.0
    total_return_pct: float = 0.0
    num_positions: int = 0
    top_holdings: list[dict] = field(default_factory=list)
    sector_weights: dict[str, float] = field(default_factory=dict)
    portfolio_beta: float = 1.0

    def to_summary(self) -> str:
        """Generate text summary for prompts."""
        lines = [
            f"Total Value: ${self.total_value:,.2f}",
            f"Cash: ${self.cash_balance:,.2f} ({self.cash_balance/self.total_value*100:.1f}%)" if self.total_value > 0 else "Cash: $0",
            f"Positions: {self.num_positions}",
            f"Today's P&L: ${self.day_pnl:+,.2f} ({self.day_return_pct:+.2f}%)",
            f"Total Return: {self.total_return_pct:+.2f}%",
            f"Portfolio Beta: {self.portfolio_beta:.2f}",
        ]

        if self.top_holdings:
            lines.append("\nTop Holdings:")
            for h in self.top_holdings[:5]:
                lines.append(f"  {h.get('symbol', 'N/A')}: {h.get('weight', 0):.1f}% (${h.get('value', 0):,.0f})")

        if self.sector_weights:
            lines.append("\nSector Allocation:")
            for sector, weight in sorted(self.sector_weights.items(), key=lambda x: -x[1])[:5]:
                lines.append(f"  {sector}: {weight:.1f}%")

        return "\n".join(lines)


@dataclass
class MarketContext:
    """Market context for copilot analysis."""

    spy_price: float = 0.0
    spy_change_pct: float = 0.0
    vix: float = 0.0
    market_trend: str = "neutral"  # bullish, neutral, bearish
    sector_performance: dict[str, float] = field(default_factory=dict)
    economic_events: list[str] = field(default_factory=list)
    market_hours: str = "closed"  # pre, open, after, closed

    def to_summary(self) -> str:
        """Generate text summary for prompts."""
        lines = [
            f"S&P 500: ${self.spy_price:.2f} ({self.spy_change_pct:+.2f}%)",
            f"VIX: {self.vix:.1f}",
            f"Market Trend: {self.market_trend.title()}",
            f"Market Status: {self.market_hours.title()}",
        ]

        if self.sector_performance:
            lines.append("\nSector Performance Today:")
            sorted_sectors = sorted(self.sector_performance.items(), key=lambda x: -x[1])
            for sector, perf in sorted_sectors[:3]:
                lines.append(f"  {sector}: {perf:+.2f}%")
            for sector, perf in sorted_sectors[-2:]:
                lines.append(f"  {sector}: {perf:+.2f}%")

        if self.economic_events:
            lines.append("\nUpcoming Events:")
            for event in self.economic_events[:3]:
                lines.append(f"  - {event}")

        return "\n".join(lines)


@dataclass
class AnalysisRequest:
    """Request for copilot analysis."""

    analysis_type: AnalysisType
    user_message: str = ""
    symbol: Optional[str] = None
    preferences: Optional[CopilotPreferences] = None
    portfolio_context: Optional[PortfolioContext] = None
    market_context: Optional[MarketContext] = None
    additional_context: dict = field(default_factory=dict)


@dataclass
class AnalysisResponse:
    """Response from copilot analysis."""

    content: str
    analysis_type: AnalysisType
    symbols_mentioned: list[str] = field(default_factory=list)
    trade_ideas: list[TradeIdea] = field(default_factory=list)
    confidence_score: float = 0.0
    tokens_used: int = 0
    model: str = ""
    processing_time_ms: float = 0.0

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "content": self.content,
            "analysis_type": self.analysis_type.value,
            "symbols_mentioned": self.symbols_mentioned,
            "trade_ideas": [t.to_dict() for t in self.trade_ideas],
            "confidence_score": self.confidence_score,
            "tokens_used": self.tokens_used,
            "model": self.model,
            "processing_time_ms": self.processing_time_ms,
        }
