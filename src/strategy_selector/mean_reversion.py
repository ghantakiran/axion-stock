"""Mean-Reversion Strategy — complements the trend-following EMA Cloud.

Identifies overbought/oversold conditions using RSI, Bollinger Bands,
and Z-score deviation from moving averages.
"""

from __future__ import annotations

import math
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Any, Optional


@dataclass
class MeanReversionConfig:
    """Configuration for the mean-reversion strategy.

    Attributes:
        rsi_period: RSI lookback period.
        rsi_oversold: RSI below this = buy signal.
        rsi_overbought: RSI above this = sell signal.
        zscore_period: Period for Z-score calculation.
        zscore_entry: Z-score magnitude to trigger entry.
        zscore_exit: Z-score magnitude to trigger exit.
        bb_period: Bollinger Band period.
        bb_std: Bollinger Band standard deviations.
        min_atr_filter: Minimum ATR for volatility filter.
        max_hold_bars: Maximum bars to hold a mean-reversion trade.
    """

    rsi_period: int = 14
    rsi_oversold: float = 30.0
    rsi_overbought: float = 70.0
    zscore_period: int = 50
    zscore_entry: float = 2.0
    zscore_exit: float = 0.5
    bb_period: int = 20
    bb_std: float = 2.0
    min_atr_filter: float = 0.5
    max_hold_bars: int = 10


@dataclass
class MeanReversionSignal:
    """Signal generated by the mean-reversion strategy.

    Attributes:
        ticker: Instrument symbol.
        direction: bullish (oversold bounce) or bearish (overbought fade).
        conviction: Signal strength 0-100.
        rsi: Current RSI value.
        zscore: Z-score from moving average.
        bb_position: Position within Bollinger Bands (0=lower, 1=upper).
        entry_price: Suggested entry price (current close).
        target_price: Mean-reversion target (moving average).
        stop_price: Stop loss price.
        signal_type: Type of mean-reversion signal detected.
        timestamp: When the signal was generated.
    """

    ticker: str = ""
    direction: str = "neutral"
    conviction: float = 0.0
    rsi: float = 50.0
    zscore: float = 0.0
    bb_position: float = 0.5
    entry_price: float = 0.0
    target_price: float = 0.0
    stop_price: float = 0.0
    signal_type: str = "none"
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

    def to_dict(self) -> dict[str, Any]:
        return {
            "ticker": self.ticker,
            "direction": self.direction,
            "conviction": round(self.conviction, 1),
            "rsi": round(self.rsi, 1),
            "zscore": round(self.zscore, 2),
            "bb_position": round(self.bb_position, 3),
            "entry_price": round(self.entry_price, 2),
            "target_price": round(self.target_price, 2),
            "stop_price": round(self.stop_price, 2),
            "signal_type": self.signal_type,
            "timestamp": self.timestamp.isoformat(),
        }


class MeanReversionStrategy:
    """Mean-reversion signal generator using RSI + Z-score + Bollinger Bands.

    Produces buy signals when price is oversold (below mean) and
    sell signals when price is overbought (above mean). Designed
    to complement the EMA Cloud trend-following strategy.

    Args:
        config: MeanReversionConfig with thresholds.

    Example:
        strategy = MeanReversionStrategy()
        signal = strategy.analyze(
            ticker="AAPL",
            closes=[185, 183, 181, 179, 180, 182, ...]
        )
        if signal.conviction > 60:
            execute_trade(signal)
    """

    def __init__(self, config: MeanReversionConfig | None = None) -> None:
        self.config = config or MeanReversionConfig()

    def analyze(
        self, ticker: str, closes: list[float], highs: list[float] | None = None,
        lows: list[float] | None = None,
    ) -> MeanReversionSignal:
        """Analyze a price series for mean-reversion signals.

        Args:
            ticker: Symbol to analyze.
            closes: List of closing prices (oldest first).
            highs: Optional high prices for ATR calculation.
            lows: Optional low prices for ATR calculation.

        Returns:
            MeanReversionSignal with conviction and entry/target/stop.
        """
        if len(closes) < max(self.config.rsi_period, self.config.zscore_period, self.config.bb_period) + 5:
            return MeanReversionSignal(ticker=ticker, signal_type="insufficient_data")

        current_price = closes[-1]

        # Compute indicators
        rsi = self._compute_rsi(closes)
        zscore = self._compute_zscore(closes)
        bb_pos, bb_upper, bb_lower, bb_mid = self._compute_bollinger(closes)

        # Determine signal
        signal_type = "none"
        direction = "neutral"
        conviction = 0.0
        target_price = bb_mid
        stop_price = current_price

        # Oversold conditions (buy signal)
        oversold_score = 0.0
        if rsi < self.config.rsi_oversold:
            oversold_score += (self.config.rsi_oversold - rsi) / self.config.rsi_oversold * 40
        if zscore < -self.config.zscore_entry:
            oversold_score += min(30, abs(zscore) * 15)
        if bb_pos < 0.05:  # Near lower band
            oversold_score += 30

        # Overbought conditions (sell signal)
        overbought_score = 0.0
        if rsi > self.config.rsi_overbought:
            overbought_score += (rsi - self.config.rsi_overbought) / (100 - self.config.rsi_overbought) * 40
        if zscore > self.config.zscore_entry:
            overbought_score += min(30, abs(zscore) * 15)
        if bb_pos > 0.95:  # Near upper band
            overbought_score += 30

        if oversold_score > overbought_score and oversold_score > 30:
            direction = "bullish"
            conviction = min(100, oversold_score)
            signal_type = "oversold_bounce"
            target_price = bb_mid
            atr_est = self._estimate_atr(closes)
            stop_price = current_price - 2 * atr_est
        elif overbought_score > oversold_score and overbought_score > 30:
            direction = "bearish"
            conviction = min(100, overbought_score)
            signal_type = "overbought_fade"
            target_price = bb_mid
            atr_est = self._estimate_atr(closes)
            stop_price = current_price + 2 * atr_est

        return MeanReversionSignal(
            ticker=ticker,
            direction=direction,
            conviction=conviction,
            rsi=rsi,
            zscore=zscore,
            bb_position=bb_pos,
            entry_price=current_price,
            target_price=target_price,
            stop_price=stop_price,
            signal_type=signal_type,
        )

    def scan_universe(
        self, prices: dict[str, list[float]], min_conviction: float = 50.0
    ) -> list[MeanReversionSignal]:
        """Scan multiple tickers for mean-reversion signals.

        Args:
            prices: Dict of ticker → closing prices.
            min_conviction: Minimum conviction to include.

        Returns:
            List of signals sorted by conviction (highest first).
        """
        signals = []
        for ticker, closes in prices.items():
            sig = self.analyze(ticker, closes)
            if sig.conviction >= min_conviction:
                signals.append(sig)
        signals.sort(key=lambda s: s.conviction, reverse=True)
        return signals

    # ── Indicator computations ───────────────────────────────────────

    def _compute_rsi(self, closes: list[float]) -> float:
        """Compute RSI using Wilder's smoothing."""
        period = self.config.rsi_period
        if len(closes) < period + 1:
            return 50.0

        deltas = [closes[i] - closes[i - 1] for i in range(1, len(closes))]
        gains = [max(0, d) for d in deltas[-period:]]
        losses = [max(0, -d) for d in deltas[-period:]]

        avg_gain = sum(gains) / period
        avg_loss = sum(losses) / period

        if avg_loss < 1e-10:
            return 100.0
        rs = avg_gain / avg_loss
        return 100.0 - (100.0 / (1.0 + rs))

    def _compute_zscore(self, closes: list[float]) -> float:
        """Compute Z-score of current price from moving average."""
        period = self.config.zscore_period
        if len(closes) < period:
            return 0.0

        window = closes[-period:]
        mean = sum(window) / period
        variance = sum((x - mean) ** 2 for x in window) / period
        std = math.sqrt(variance) if variance > 0 else 1e-10

        return (closes[-1] - mean) / std

    def _compute_bollinger(
        self, closes: list[float]
    ) -> tuple[float, float, float, float]:
        """Compute Bollinger Band position.

        Returns:
            (position 0-1, upper_band, lower_band, middle_band)
        """
        period = self.config.bb_period
        if len(closes) < period:
            return 0.5, closes[-1], closes[-1], closes[-1]

        window = closes[-period:]
        mid = sum(window) / period
        variance = sum((x - mid) ** 2 for x in window) / period
        std = math.sqrt(variance)

        upper = mid + self.config.bb_std * std
        lower = mid - self.config.bb_std * std

        band_width = upper - lower
        if band_width < 1e-10:
            return 0.5, upper, lower, mid

        position = (closes[-1] - lower) / band_width
        position = max(0.0, min(1.0, position))

        return position, upper, lower, mid

    def _estimate_atr(self, closes: list[float], period: int = 14) -> float:
        """Estimate ATR from closes only (true range approximation)."""
        if len(closes) < period + 1:
            return abs(closes[-1]) * 0.02

        true_ranges = []
        for i in range(1, min(period + 1, len(closes))):
            tr = abs(closes[-i] - closes[-i - 1])
            true_ranges.append(tr)

        return sum(true_ranges) / len(true_ranges) if true_ranges else abs(closes[-1]) * 0.02
