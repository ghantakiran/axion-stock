"""Data models for compliance engine."""

from dataclasses import dataclass, field
from datetime import date, datetime
from typing import Any, Dict, List, Optional


@dataclass
class TradePattern:
    """A detected trade pattern for surveillance."""

    symbol: str
    pattern_type: str
    trades: List[Dict[str, Any]] = field(default_factory=list)
    confidence: float = 0.0
    details: str = ""


@dataclass
class SurveillanceAlert:
    """Alert generated by trade surveillance."""

    alert_id: str
    alert_type: str
    severity: str
    symbol: str
    account_id: str = ""
    trader_id: str = ""
    pattern: Optional[TradePattern] = None
    description: str = ""
    is_resolved: bool = False
    resolved_by: Optional[str] = None
    resolved_at: Optional[datetime] = None
    created_at: datetime = field(default_factory=datetime.now)


@dataclass
class BlackoutWindow:
    """Insider trading blackout window."""

    window_id: str
    symbol: str
    reason: str
    start_date: date
    end_date: date
    created_by: str = ""
    affected_persons: List[str] = field(default_factory=list)
    is_active: bool = True

    def is_in_blackout(self, check_date: date) -> bool:
        return self.is_active and self.start_date <= check_date <= self.end_date


@dataclass
class PreClearanceRequest:
    """Pre-clearance request for insider trading compliance."""

    request_id: str
    requester_id: str
    symbol: str
    side: str
    quantity: int
    estimated_value: float = 0.0
    approved: Optional[bool] = None
    approved_by: Optional[str] = None
    valid_until: Optional[date] = None
    reason: str = ""
    submitted_at: datetime = field(default_factory=datetime.now)

    @property
    def is_pending(self) -> bool:
        return self.approved is None

    @property
    def is_valid(self) -> bool:
        if self.approved is not True:
            return False
        if self.valid_until and date.today() > self.valid_until:
            return False
        return True


@dataclass
class ExecutionMetric:
    """Single execution quality measurement."""

    order_id: str
    symbol: str
    side: str
    quantity: int
    limit_price: float
    fill_price: float
    benchmark_price: float
    slippage_bps: float = 0.0
    price_improvement_bps: float = 0.0
    quality: str = "acceptable"
    venue: str = ""
    executed_at: datetime = field(default_factory=datetime.now)


@dataclass
class BestExecutionReport:
    """Aggregate best execution analysis."""

    period_start: date
    period_end: date
    total_orders: int = 0
    avg_slippage_bps: float = 0.0
    avg_price_improvement_bps: float = 0.0
    excellent_pct: float = 0.0
    good_pct: float = 0.0
    poor_pct: float = 0.0
    failed_pct: float = 0.0
    total_cost_saved: float = 0.0
    overall_quality: str = "acceptable"
    by_venue: Dict[str, Dict[str, float]] = field(default_factory=dict)
    generated_at: datetime = field(default_factory=datetime.now)


@dataclass
class RegulatoryFiling:
    """A regulatory filing/report."""

    filing_id: str
    report_type: str
    title: str
    period_start: date
    period_end: date
    content: Dict[str, Any] = field(default_factory=dict)
    filed: bool = False
    filed_at: Optional[datetime] = None
    generated_at: datetime = field(default_factory=datetime.now)


@dataclass
class ComplianceSummary:
    """Overall compliance health summary."""

    period: str
    surveillance_alerts: int = 0
    unresolved_alerts: int = 0
    blackout_violations: int = 0
    best_execution_score: float = 0.0
    pre_clearance_pending: int = 0
    filings_due: int = 0
    overall_status: str = "compliant"
    generated_at: datetime = field(default_factory=datetime.now)
